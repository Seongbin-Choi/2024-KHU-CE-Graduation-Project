# -*- coding: utf-8 -*-
"""졸프_11_27(데이터 통합 스케일링)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1URaoVzRDxT1KTdi_0FMkQ5Khi3bMFMiD
"""

!pip install -U finance-datareader

import FinanceDataReader as fdr
import pandas as pd
import numpy as np
from datetime import datetime, date, timedelta

from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout, Flatten
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

train_start = '2016-01-01'
train_end = '2024-09-30'

# 삼성전자 주가, KOSPI, 환율 주가 가져오기
df_ss = fdr.DataReader('005930', train_start, train_end)
df_ks = fdr.DataReader('KS11', train_start, train_end)
df_fx = fdr.DataReader('USD/KRW', train_start, train_end)


# 공통된 날짜 필터링
common_dates = df_ss.index.intersection(df_ks.index).intersection(df_fx.index)
df_ss = df_ss.loc[common_dates]
df_ks = df_ks.loc[common_dates]
df_fx = df_fx.loc[common_dates]

# 일별 변동률 계산
df_ss['Change'] = df_ss['Close'].pct_change()
df_ks['Change'] = df_ks['Close'].pct_change()
df_fx['Change'] = df_fx['Close'].pct_change()

# 결측치 제거
df_ss = df_ss.dropna()
df_ks = df_ks.dropna()
df_fx = df_fx.dropna()

# 결측치 확인
print("삼성전자 데이터 결측치 확인: ", common_dates.isna().sum())

# 변동률 데이터를 병합하여 하나의 데이터프레임으로 생성
combined_df = pd.concat([df_ss['Change'], df_ks['Change'], df_fx['Change']], axis=1)
combined_df.columns = ['SS_Change', 'KS_Change', 'FX_Change']

# 결측치가 있는 행 제거 (혹시 모를 결측치 처리)
combined_df = combined_df.dropna()

# 통합 스케일링
scaler = MinMaxScaler()
combined_scaled = scaler.fit_transform(combined_df)

# 스케일링된 데이터를 다시 각각 분리
ss_change = combined_scaled[:, 0].reshape(-1, 1)
ks_change = combined_scaled[:, 1].reshape(-1, 1)
fx_change = combined_scaled[:, 2].reshape(-1, 1)

# 데이터의 길이를 최소 길이로 맞추기
min_length = min(len(ss_change), len(ks_change), len(fx_change))
ss_change = ss_change[:min_length]
ks_change = ks_change[:min_length]
fx_change = fx_change[:min_length]

# 데이터를 병합 (삼성전자 변동률, KOSPI 변동률, 환율 변동률)
time_step = 10
combined_data = []

for i in range(len(ss_change) - time_step):
    combined_data.append(np.concatenate((ss_change[i:i+time_step], ks_change[i:i+time_step], fx_change[i:i+time_step]), axis=1))
combined_data = np.array(combined_data)

# 학습 및 테스트 데이터 분리
X = combined_data[:, :-1]
y = combined_data[:, -1][:, 0]  # 삼성전자 변동률만 예측 대상으로 설정
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

# 모델 정의 (LSTM Layers)
model = Sequential()
model.add(LSTM(128, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(LSTM(128))
model.add(Dense(1))

# 컴파일 및 학습
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X_train, y_train, epochs=50, batch_size=8)

# 실제 주가 예측을 위한 초기값 설정 (마지막 학습 데이터의 실제 주가로 초기화)
last_actual_price = df_ss['Close'].iloc[-1]

# 예측할 날짜 범위 설정
prediction_results = []
predict_start = '2024-03-01'
end_date = datetime.today().strftime('%Y-%m-%d')
current_date = datetime.strptime(predict_start, '%Y-%m-%d')

while current_date <= datetime.strptime(end_date, '%Y-%m-%d'):
    ahead = current_date - timedelta(days=30)
    try:
        # 데이터 가져오기 및 변동률 계산 (기존 코드와 동일)
        df_ss = fdr.DataReader('005930', ahead, current_date)
        df_ks = fdr.DataReader('KS11', ahead, current_date)
        df_fx = fdr.DataReader('USD/KRW', ahead, current_date)

        # 변동률 계산 및 결측치 제거
        df_ss['Change'] = df_ss['Close'].pct_change()
        df_ks['Change'] = df_ks['Close'].pct_change()
        df_fx['Change'] = df_fx['Close'].pct_change()
        df_ss, df_ks, df_fx = df_ss.dropna(), df_ks.dropna(), df_fx.dropna()

        # 공통된 날짜 필터링
        common_dates = df_ss.index.intersection(df_ks.index).intersection(df_fx.index)
        df_ss_common, df_ks_common, df_fx_common = df_ss.loc[common_dates], df_ks.loc[common_dates], df_fx.loc[common_dates]

        # Change 값 추출 및 스케일링
        combined_df = pd.concat([df_ss_common['Change'], df_ks_common['Change'], df_fx_common['Change']], axis=1).dropna()
        combined_df.columns = ['SS_Change', 'KS_Change', 'FX_Change']
        scaled_data = scaler.transform(combined_df)

        ss_change, ks_change, fx_change = scaled_data[:, 0], scaled_data[:, 1], scaled_data[:, 2]

        # 시계열 데이터 생성
        combined_data = []
        for i in range(len(ss_change) - time_step):
            combined_data.append(np.column_stack((ss_change[i:i+time_step], ks_change[i:i+time_step], fx_change[i:i+time_step])))
        combined_data = np.array(combined_data)

        # combined_data가 비어 있는 경우 건너뛰기
        if combined_data.size == 0:
            print(f"Skipping {current_date}: combined_data is empty after concatenation.")
            current_date += timedelta(days=1)
            continue

        # 입력 데이터 형태 조정
        X_new = combined_data.reshape((combined_data.shape[0], time_step, -1))

        # 예측 수행
        predicted_data_scaled = model.predict(X_new, verbose=0)
        predicted_change_scaled = predicted_data_scaled[-1][0]  # 마지막 시계열 데이터의 예측 결과 사용

        # 스케일링 해제하여 변동률 추출
        predicted_change = scaler.inverse_transform([[predicted_change_scaled, 0, 0]])[0][0]  # 변동률 값을 스칼링 해제

        # 변동률을 이용해 다음 주가 예측
        next_price = last_actual_price * (1 + predicted_change)

        # 예측 결과 저장
        prediction_results.append((current_date, next_price))
        print(f'Prediction for {current_date}: {next_price}')

        # 다음 예측을 위해 last_actual_price 업데이트
        last_actual_price = next_price

    except ValueError as e:
        print(f"Skipping {current_date}: {e}")
        pass

    # 다음 날짜로 이동
    current_date += timedelta(days=1)

# 결과 출력
print("Prediction Results:", prediction_results)

# prediction_results

import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime
import FinanceDataReader as fdr

# 예측 결과를 데이터프레임으로 변환
df_prediction = pd.DataFrame(prediction_results, columns=['Date', 'Prediction'])

# 실제 삼성전자 주가 데이터를 가져와 공통된 날짜로 필터링
df_ss = fdr.DataReader('005930', predict_start, end_date)
df_ss_common = df_ss[df_ss.index.isin(df_prediction['Date'])]

# 예측 날짜와 실제 데이터 시각화
plt.figure(figsize=(10, 6))
plt.plot(df_ss_common.index, df_ss_common['Close'], label='SS Actual', color='blue')
plt.plot(df_prediction['Date'], df_prediction['Prediction'], label='Prediction', color='green', marker='o')

plt.xlabel('Date')
plt.ylabel('Price')
plt.title('SS Actual Prices vs. Predictions (With Exchange Rate)')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

print(len(df_ss_common.index))
print(len(df_ss_common['Close'].values))
print(len(df_prediction['Prediction'].values))

# 공통된 날짜를 기준으로 예측 값 필터링
df_prediction_filtered = df_prediction[df_prediction['Date'].isin(df_ss_common.index)].set_index('Date')
df_prediction_filtered = df_prediction_filtered.reindex(df_ss_common.index).dropna()

# 공통된 데이터프레임 생성
df_result = pd.DataFrame({
    'Date': df_ss_common.index,
    'Actual': df_ss_common['Close'].values,
    'Predicted': df_prediction_filtered['Prediction'].values
})

# Previous 열 생성 및 결측치 처리
df_result['Previous'] = df_result['Actual'].shift(1).fillna(0)

# Predicted 값이 배열일 경우 처리
if isinstance(df_result['Predicted'].iloc[0], np.ndarray):
    df_result['Predicted'] = df_result['Predicted'].apply(lambda x: x[0])
else:
    df_result['Predicted'] = df_result['Predicted']

# 차이 계산
df_result['Difference'] = df_result['Actual'] - df_result['Previous']

# Guess 및 Evaluate 열 생성
df_result['Guess'] = ''
df_result['Evaluate'] = ''

# 조건 적용 함수 정의
def apply_conditions(row):
    if row['Predicted'] > row['Previous']:
        row['Guess'] = 'Up'
        row['Evaluate'] = 'Good' if row['Difference'] >= 0 else 'Bad'
    elif row['Predicted'] == row['Previous']:
        row['Guess'] = '-'
        row['Evaluate'] = 'Good' if row['Difference'] == 0 else 'Bad'
    else:
        row['Guess'] = 'Down'
        row['Evaluate'] = 'Good' if row['Difference'] < 0 else 'Bad'
    return row

# Apply 함수 적용
df_result = df_result.apply(apply_conditions, axis=1)

# 첫 번째 행 제거 (필요한 경우)
df_result = df_result.drop(df_result.index[0])

# 최종 결과 확인
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
pd.set_option('display.max_colwidth', None)

print(df_result.tail(30))

# 정확도 계산
total = df_result.shape[0]
correct = df_result['Evaluate'].str.count("Good").sum()
accuracy = correct / total
print(f"{accuracy*100:.3f}%")









